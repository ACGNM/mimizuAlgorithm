# 树
## 二叉树
### 完全二叉树的数组表示下的位置关系

- 位置k的节点的左子节点位置为`2k+1`, 右子节点的位置为`2k+2`
  - 完全二叉树在满叶节点的情况下第`i`层的节点数是`i-1`层的`2`倍
  - 如果`0~i`层的节点个数总和是`n`，则第i+1层节点个数是`n+1`
    - 这里的`n`是奇数，也就是`(2^i)-1`
    - 数组的编号要从0开始，所以第`i`层最后一个元素编号是`n-1`
    - 第`i+1`层的最后一个编号（i层最后一个节点的右子节点）是上一层编号加经过点的个数
    - i层最后一个元素编号是`k`的话，就说明要经过`k+2`（也就是`(k+1)+1`）个位置
    - 所以第`i+1`层的最后一个编号是`2k+2`，那左子节点就是2k-1
    - 第i层的往回推j个格仍然成立
      - i层退`j`个，`i+1`层退2j个
      - `k-j`对应的是`2k+2-2j=2(k-j)+2`

  一开始的推算想法
  - 下面推算数`i-1`层的第一个节点的子节点位置
    - 从`0`开始数节点的话，每一层的第一个节点的位置正好符合上面的规律，即每一层的第一个节点需要再经过`n+1`个位置就是其左子节点位置即`2n+1`。这时n的位置的值恰好为`0~i-2`层的节点数总和
    - 由此扩展开去，第`k`个位置相当于第一个节点向后移动了j个位置即`k=n+j`。此时第`n`个位置的左子节点位置为`2n+1`, 则再经过j个节点的子节点就为k的左子结点位置：`2n+1 + 2j = 2(n+j)+1 = 2k+1`

## 遍历

### 前序遍历
- 中→左→右
### 中序遍历
- 左→中→右
### 后序遍历
- 左→右→中

### 用循环的方式遍历的设计思想
- 因为叶子节点的值会先被输出，所以基本想法是从根到叶一次入栈然后出栈
- 不考虑节点间的可达性，入栈顺序应该是遍历顺序的取反
- 但是如果真的按照遍历顺序的取反来入栈的话，先入了叶节点之后还要回溯父节点
  - 需要牺牲内存来存储父节点信息
- 这时可以以父节点为中心，使用中左右的方式
   - 即先入中间，如果有左子节点则一并入栈（对于每一个入栈的左子节点也是同样的道理，这时把入栈的左子节点作为新的中间节点来对待）
   - 这时左叶节点先出栈，然后栈中轮到中间节点出栈，顺便通过中间节点获取右子节点情报
- 影响最后遍历输出顺序的只是在哪里记录输出结果
  - 前序，节点入栈的时候就输出，这样中间的就先出输出
    - 因为对于每个节点他对自己来说都是中间节点
  - 中序，到达最左之后再输出，确保先输出左边的
    - 需要达到当前父节点的最左子节点
  - 后序，左边按照中序想法，因为最先输出。输出中之前先判断上一个输出的是不是右子节点，然后再输出

#### 按照只有两层的完全二叉树的理想情况来说，伪代码可以是
```
stack.push(root)
stack.push(root.left)
stack.pop()
curr = stack.pop()
stack.push(curr.right)
stack.pop()
```
然后向多层扩展开去就添加找到最左的节点为止一直入栈
是否一直入栈要看上一个是不是叶节点或者说右边没有需要再输出的了（也就是最后root = root.right）
