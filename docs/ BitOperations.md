## 补码总结

- 就是一个由于位数有限，从而等效在环上的运算方式
- 只是追求在这个环的范围内可以得到正确结果
- 减去一个数相当于加上另一个数，前提是这两个数的和是模，也就是这个环的最大值（2^位数）
- 而减去一个数相当于加上一个负数
- 所以补码就是寻找某个负数的另一个等效的数
- 根据上面的结论，等效的数应该是模-负数的绝对值，在二进制中就是 （全1 + 1）- 负数绝对值原码 = 全1 - 负数绝对值原码 + 1
  - 其中（全1 + 1）就是模的值，因为位数限制这样计算
  - 全1 - 负数绝对值原码 就是取反
  - 也就是按位取反+1 → 补码计算方法的由来

- 实际计算中都是补码形式表示
  - 正数的补码就是本身，所以最后转换的时候不用再按位取反还原后表示为10进制
  - 计算后会根据次高位上和符号上的进位是否一致来判断是否溢出
    - 溢出了就会提示错误，因为按照现在的规格无法显示正确的十进制结果

## 位运算常用场景

- 对2^n取模
  - 相当于和2^n - 1进行与运算（因为2^n一般是1000000的形式，减一就是高位为0，低位都为1，与运算之后保留地位高位清除）
  - 一般与运算速度快于模运算
  - HashMap中也使用与运算代替模运算寻找位置。而且一般HashMap的size会初始化为2的n次幂

- 判断奇偶数
  - 二进制最后一位是1就是奇数，所以与一个1就可以判断

- 数字翻倍减半
  - 左移右移
  - java的ArrayList的扩容 size + size >> 1 (原来容量的1.5倍)

- 交换两个数
  - a = a ^ b, b = a ^ b, a = a ^ b (异或)

